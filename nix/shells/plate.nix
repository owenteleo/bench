{
  self,
  system,
  lib,
  pkgs,
  ...
}:
let
  # ANSI color codes helper.
  # Alternatives include:
  # - https://github.com/phip1611/ansi-escape-sequences-cli
  #   - https://crates.io/crates/ansi-escape-sequences-cli
  #   - https://github.com/NixOS/nixpkgs/blob/c618e28f70257593de75a7044438efc1c1fc0791/pkgs/by-name/an/ansi/package.nix#L19
  ansi = import (self + /nix/derivations/ansi.nix) {
    inherit pkgs;
    inherit system;
  };
in
pkgs.mkShell {
  name = "testbench shell";
  buildInputs = with pkgs; [
    python3
    can-utils
    fzf
    git
    ripgrep
    coreutils
    uutils-coreutils-noprefix

    # just for fun...
    lolcat
    cowsay
    glibcLocales
  ] ++ [
    ansi
  ];

  shellHook = ''
    setup() {
      export PATH="${pkgs.uutils-coreutils-noprefix}/bin:$PATH"
      export PATH="$(pwd)/bin:$PATH"

      # if the shell is bash, enable autocompletion
      if [ -n "$BASH_VERSION" ]; then
        source bin/bench-complete.bash
        echo "$(ansi --bold --color=34 "info:") Autocompletion enabled."
      else
        echo "$(ansi --bold --color=220 "warning:") Unrecognized shell interpreter. Autocompletion not enabled."
      fi
    }

    customize() {
      export PS1="\[\033[38;5;9m\]\u\[\033[0m\]@\[\033[38;5;175m\]\h\[\033[0m\]:\[\033[38;5;33m\]\w\[\033[0m]% "

      prompt_update() {
        echo -ne "\033]0;gym: $(pwd) ðŸ’ªðŸ’ªðŸ’ª\007"
      }
      export PROMPT_COMMAND=prompt_update
    }

    colors() {
      ansi --color-codes
    }

    gencomplete() {
      # uses click to generate shell completions
      echo "Generating shell completions..."

      shells=(
        bash
        zsh
        fish
      )
      for shell in "''${shells[@]}"; do
        outfile=bin/bench-complete.$shell

        echo "# AUTO-GENERATED FILE - DO NOT EDIT" > $outfile
        echo "# \"$shell\" autocompletion automatically generated by 'gencomplete'." >> $outfile
        echo "" >> $outfile
        _BENCH_COMPLETE="$shell"_source bench >> $outfile
      done
      echo "Done."

      read -p "$(ansi --bold --color=220 "warning:") Changes to autocomplete will not take effect until the shell is reloaded. Press Enter to acknowlege." -n 1 -r
    }

    grab() {
      # grabs the first available serial port
      # usage: grab [filter]
      filter=USB0
      if [ -n "$1" ]; then
          filter=$1
      fi
      
      PORTS=$(ls /dev/tty* 2>/dev/null)
      if [ -z "$PORTS" ]; then
        echo "No serial ports found."
        return
      fi

      PORT=$(echo $PORTS | tr " " "\n" | fzf --filter="$filter")

      if [ -z "$PORT" ]; then
        echo "No port selected."
          return
      else
        echo "Selected port: $PORT"
      fi
      export PORT=$PORT
    }

    monitor() {
      # monitor the serial port with python pyserial
      MONITOR_PORT=$1
      if [ -z "$MONITOR_PORT" ]; then
        MONITOR_PORT=$PORT
      fi
      if [ -z "$MONITOR_PORT" ]; then
        echo "No port specified."
        return
      fi
      echo using port $MONITOR_PORT
      python -m serial.tools.miniterm $MONITOR_PORT 115200
    }

    gronk() {
      # like grab() except for socketcan interfaces
      filter=can0
      if [ -n "$1" ]; then
        filter=$1
      fi

      INTERFACES=$(ip link show | rg -o '^[0-9]+: [a-zA-Z0-9]+:' | cut -d' ' -f2 | cut -d':' -f1)
      if [ -z "$INTERFACES" ]; then
        echo "No interfaces found."
        return
      fi

      INTERFACE=$(echo $INTERFACES | tr " " "\n" | fzf --filter="$filter")

      if [ -z "$INTERFACE" ]; then
        echo "No interface selected."
        return
      else
        echo "Selected interface: $INTERFACE"
      fi
      export CAN=$INTERFACE
    }

    grank() {
      # create a virtual can interface
      name=$1
      if [ -z "$1" ]; then
        # prompt for the name using read
        read -p "Enter the name of the virtual CAN interface: " name
      fi

      if [ -z "$name" ]; then
        echo "No name specified."
        return
      fi

      if ! ip link show $name | rg -q "state UP"; then
        grank_interface() {
          echo "Creating virtual CAN interface $1"
          sudo ip link add dev $1 type vcan
          sudo ip link set $1 up
          echo "Done."
        }

        if [[ $EUID -ne 0 ]]; then
          echo "Creating virtual CAN interface requires root access."
          sudo bash -c "$(declare -f grank_interface); grank_interface $name"
        else
          grank_interface $name
        fi
      else
        echo "Interface $name is already up."
      fi
    }

    rip() {
      # tear down a virtual can interface -- removing it entirely
      # does not affect physical interfaces
      name=$1
      if [ -z "$1" ]; then
        read -p "No interface name provided. You will be prompted to choose one. Press Enter to continue." -n 1 -r
        INTERFACES=$(ip link show | rg -o '^[0-9]+: [a-zA-Z0-9]+:' | cut -d' ' -f2 | cut -d':' -f1 | rg -i "vcan")
        name=$(echo $INTERFACES | tr " " "\n" | fzf)
      fi
      if [ -z "$name" ]; then
        echo "No interface selected."
        return
      fi

      if ! ip link show $name | rg -q "vcan"; then
        echo "Interface $name is not a virtual CAN interface."
        return
      fi

      if ip link show $name | rg -q "state UP"; then
        echo "Interface $name is up. Tearing it down..."
        sudo ip link set $name down
      fi

      # remove the interface
      echo "Removing interface $name"
      sudo ip link delete $name
      echo "Done."
    }

    pour() {
      # sets up the can interface
      MONITOR_CAN=$1
      if [ -z "$MONITOR_CAN" ]; then
        MONITOR_CAN=$CAN
      fi
      if [ -z "$MONITOR_CAN" ]; then
        echo "No interface specified."
        return
      fi

      BAUDRATE=$2
      if [ -z "$BAUDRATE" ]; then
        BAUDRATE=$(echo -e "125000\n250000\n500000\n1000000" | fzf -q 5)
      fi
      if [ -z "$BAUDRATE" ]; then
        echo "No baudrate specified."
        return
      fi

      if ! ip link show $MONITOR_CAN | rg -q "state UP"; then
        pour_into() {
          echo "Setting up can interface $1 with bitrate $2"
          sudo ip link set $1 up type can bitrate $2
          echo "Done."
        }

        if [[ $EUID -ne 0 ]]; then
          echo "Configuring CAN interface requires root access."
          sudo bash -c "$(declare -f pour_into); pour_into $MONITOR_CAN $BAUDRATE"
        else
          pour_into $MONITOR_CAN $BAUDRATE
        fi
      else
        echo "Interface $MONITOR_CAN is already up."
      fi
    }

    drink() {
      # sets down the can interface
      MONITOR_CAN=$1
      if [ -z "$MONITOR_CAN" ]; then
        MONITOR_CAN=$CAN
      fi
      if [ -z "$MONITOR_CAN" ]; then
        echo "No interface specified."
        return
      fi

      if ip link show $MONITOR_CAN | rg -q "state UP"; then
        drink_from() {
          echo "Tearing down can interface $1"
          sudo ip link set $1 down
          echo "Done."
        }

        if [[ $EUID -ne 0 ]]; then
          echo "Tearing down CAN interface requires root access."
          sudo bash -c "$(declare -f drink_from); drink_from $MONITOR_CAN"
        else
          drink_from $MONITOR_CAN
        fi
      else
        echo "Interface $MONITOR_CAN is already down."
      fi
    }

    stream() {
      MONITOR_CAN=$1
      if [ -z "$MONITOR_CAN" ]; then
        MONITOR_CAN=$CAN
      fi
      if [ -z "$MONITOR_CAN" ]; then
        echo "No interface specified."
        return
      fi

      if ! ip link show $MONITOR_CAN | rg -q "state UP"; then
        echo "Interface $MONITOR_CAN is not up."
        return
      fi
      python -m can.viewer -i socketcan -c $CAN
    }

    help() {
      echo "Available commands:"
      echo "  help: shows this help message"
      echo "  colors: shows ANSI color codes"
      echo "  gencomplete: generates shell completions"
      echo "  grab [filter]: grabs the first available serial port"
      echo "  monitor [PORT]: monitor the serial port with python pyserial"
      echo "  gronk [filter]: select a socketcan interface"
      echo "  grank [INTERFACE]: creates a virtual can interface"
      echo "  pour [INTERFACE] [BAUDRATE]: sets up the can interface"
      echo "  stream [INTERFACE]: streams CAN messages"
      echo ""
    }

    echo "Entered Teleo testbench development shell."
    echo "Setting up environment..."

    setup
    customize

    if [ ! -d venv ]; then
      python3 -m venv venv
    fi
    source venv/bin/activate
    pip install -r requirements.txt >> /dev/null

    echo ""
    echo "Do you even lift bro?" | cowsay | lolcat
    echo ""

    echo "Type 'help' for available commands."
  '';
}
