# keya-control

A quick dirty tool to facilitate keya JTECU integration testing.

**priority the first**

Get the JTECU to go into remote mode.

```python
JTECU_System_Mode_Command(JTECU_NUM, SystemMode.REMOTE)
```

# debugging can mesages

```bash
python -m can.viewer -i socketcan -c can0
```


# debugging with openocd and gdb

This came up a little unexpected and should utlimately not be part of this repo...

But for reference I am writing down my work.

**environment**

GDB should be specialized to the target architecture.
I set up a simple nix derivation which downloads the ARM embedded toolchain for Linux x86_64 (hard-coded for now).
This derivation gets overlayed in the shell environment so that `arm-none-eabi-xxx` uses the right version (wahoo!).
the ncurses shared lib (libncurses.so.5) needs to be accessible to the gdb binary so a shell hook is used to set the LD_LIBRARY_PATH.

openocd is provided by nixpkgs.

**openocd**

openocd comes with some configuration files for STLinkV2 and the STM32H7 series MCU.
I (GPT) wrote a simple config script to combine these options.

**debug binary**

The .elf file is generated by the build system and contains the debug symbols.




**workflow**



In one shell, for openocd
```sh
openocd -f jtecu-stlinkv3.cfg # start openocd with the custom config
```


In another shell, for gdb
```sh
nix-shell # enter the environment to get the right tools
export BINARY=/home/owen/Documents/v3_fw/cmake_build/TCU_JOY_V3/develop/GCC_ARM/v3_jtecu.bin
export BINARY_ELF=/home/owen/Documents/v3_fw/cmake_build/TCU_JOY_V3/develop/GCC_ARM/v3_jtecu.elf
arm-none-eabi-gdb $BINARY_ELF

target remote localhost:3333 # connect to openocd

# to load the binary
monitor reset halt
load # loads according to information in the .elf

# load the binary directly 
monitor reset halt
restore $BINARY binary 0x08000000
```


**helpful gdb commands**

| **Command**                | **Description**                                                                 |
|----------------------------|---------------------------------------------------------------------------------|
| `target remote <host>:<port>` | Connect to a remote target (e.g., OpenOCD).                                   |
| `monitor reset halt`       | Reset and halt the target microcontroller.                                      |
| `load`                     | Load the program onto the target from the ELF file.                             |
| `restore <file> binary <addr>` | Load a binary file to the specified address.                                 |
| `break <location>`         | Set a breakpoint at a function, line, or address.                               |
| `delete <num>`             | Remove a specific breakpoint by its number.                                     |
| `info breakpoints`         | List all breakpoints and their details.                                         |
| `continue` (`c`)           | Resume program execution.                                                      |
| `step` (`s`)               | Step into the next line of code.                                                |
| `next` (`n`)               | Step over the next line of code.                                                |
| `finish`                   | Run until the current function returns.                                         |
| `info registers`           | Display the CPU register values.                                                |
| `print <variable>`         | Print the value of a variable.                                                  |
| `set var <variable> = <value>` | Modify the value of a variable.                                             |
| `info locals`              | Display local variables in the current scope.                                   |
| `x/<fmt> <address>`        | Examine memory at an address (formats: `x` hex, `d` decimal, `s` string, etc.). |
| `disassemble <func>`       | Show disassembly for the specified function.                                    |
| `bt` (backtrace)           | Display the current call stack.                                                 |
| `frame <n>`                | Select and inspect a specific frame in the call stack.                          |
| `watch <expr>`             | Set a watchpoint for an expression (e.g., variable write access).               |
| `info watchpoints`         | List all active watchpoints.                                                    |
| `quit` (`q`)               | Exit GDB.  


| **Command**                | **Description**                                                                 |
|----------------------------|---------------------------------------------------------------------------------|
| `break HardFault_Handler`  | Break on the HardFault exception handler.                                       |
| `monitor arm vector_catch enable all` | Enable vector catch for all exception types.                               |
| `monitor arm vector_catch enable hardfault` | Enable vector catch for HardFault exceptions.                           |
| `print /x SCB->CFSR`       | Inspect the Configurable Fault Status Register.                                |
| `print /x SCB->HFSR`       | Inspect the HardFault Status Register.                                          |


break mbed_error
break mbed_die


info breakpoints

